/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.7";
  LOOKAHEAD = 1;
  STATIC = false;
}

PARSER_BEGIN(DotGParser)
package org.workcraft.plugins.stg.javacc;

import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

import org.workcraft.dom.Node;
import org.workcraft.plugins.stg.SignalTransition.Direction;
import org.workcraft.plugins.stg.SignalTransition.Type;
import org.workcraft.plugins.stg.*;
import org.workcraft.util.Pair;
import org.workcraft.util.Triple;
import org.workcraft.exceptions.InvalidConnectionException;
import org.workcraft.exceptions.FormatException;
import org.workcraft.exceptions.NotFoundException;

public class DotGParser {
	private HashMap<String, Type> signals;
	private HashSet<String> dummies;
	private HashMap<Pair<Node, Node>, STGPlace> implicitPlaces;
	private STG stg;

	private void init() {
		signals = new HashMap<String, Type>();
		dummies = new HashSet<String>();
		stg = new STG();
		implicitPlaces = new HashMap<Pair<Node, Node>, STGPlace>();
	}
	
	private Node getOrCreate (String name) {
		Node node = stg.getNodeByReference(name);
		if (node == null) {
			node = stg.getNodeByReference(name + "/0");		}			
		if (node == null) {
		  	if (dummies.contains(name)) {				node = stg.createDummyTransition(name, null);
			} else if (signals.containsKey(name)) {				node = getOrCreate(Triple.of(name, Direction.TOGGLE, 0));			} else {
				node = stg.createPlace(name, null);			}
		}
		return node;
	}
	
	private Node getOrCreate (Pair<String, Integer> ref) {		String reference = stg.makeReference(ref);
		String name = ref.getFirst();
		Node node = stg.getNodeByReference(reference);
		if (node == null) {
		  	if (dummies.contains(name)) {
				DummyTransition dt = stg.createDummyTransition(null, null);
				stg.setName(dt, reference, true);
				dt.setName(name);
				node = dt;
		  	} else if (signals.containsKey(name)) {				node = getOrCreate(Triple.of(name, Direction.TOGGLE, ref.getSecond()));
			}
		}
		return node;
	}
	
	private Node getOrCreate (Triple<String, Direction, Integer> ref) {
		String reference = stg.makeReference(ref);
		String name = ref.getFirst(); 
		Node node = stg.getNodeByReference (reference);
		if (node == null) {
			SignalTransition st = stg.createSignalTransition();
			stg.setName (st, reference, true);
			if (signals.containsKey(name)) {				st.setSignalType(signals.get(name));
				node = st;
			} else {				throw new FormatException ("Undeclared signal encountered: "
					+ name + " ("+reference+"). Possibly malformed header.");
			}
		}
		return node;
	}
	
	private void createArc (Node first, Node second) {
		try {
			ConnectionResult result = stg.connect(first, second);
			STGPlace implicitPlace = result.getImplicitPlace();
			
			if (implicitPlace != null)
				implicitPlaces.put (Pair.of (first, second), implicitPlace);
				
		} catch (InvalidConnectionException e) {
			throw new FormatException ("Cannot create arc from " + stg.getNodeReference(first) +
			 " to " + stg.getNodeReference(second) + ".", e);
		}
	}
	
	private void addSignals (List<String> list, Type type) {
		for (String name : list) {
			if (signals.containsKey(name)) {
				Type prevType = signals.get(name);
				if (!prevType.equals(type)) {
					throw new FormatException ("The " + type + " signal \"" + name + "\" was already listed as an " + prevType + " signal.");
				}
			} else if (dummies.contains(name)) {
				throw new FormatException ("The " + type + " \"" + name + "\" was already listed as a dummy.");
			} else {
				signals.put(name, type);
			}
		}
	}
	
	private void addDummies (List<String> list) {
		for (String name : list) {
			if (signals.containsKey(name)) {
				Type type = signals.get(name);
				throw new FormatException ("The dummy \"" + name + "\" was already listed as an " + type + " signal.");
			} else {
				dummies.add(name);
			}
		}
	}
}
PARSER_END(DotGParser)

< * > SKIP :
{
 	" "
|	"\t"
|	<"#" (~["\r","\n"])* (["\r", "\n"])*>
}

< IGNORE_LINE > TOKEN:
{
	<REST : (~["\r", "\n", "#"])*> : DEFAULT
}

< IGNORE_ALL > TOKEN:
{
	<ANY : ~[]>
}


TOKEN :
{
	<LINEBREAK: (["\r", "\n"])+>
  	| <INPUT_HEADER: ".inputs">
  	| <OUTPUT_HEADER: ".outputs">
  	| <INTERNAL_HEADER: ".internal">
  	| <DUMMY_HEADER: ".dummy">
  	| <GRAPH: ".graph">
  	| <MARKING: ".marking">
  	| <CAPACITY: ".capacity">
	| <END: ".end"> : IGNORE_ALL
	| <UNSUPPORTED_HEADER: "." <NAME>> : IGNORE_LINE
  	| <NAME: ["A"-"Z","a"-"z","_"](["_","A"-"Z","a"-"z","0"-"9"])*>
  	| <DIRECTION: ["+","-","~"]>
  	| <INTEGER: (["0"-"9"])+>
  	| "{" | "}" | "<" | ">" | "," | "/" | "="
}

STG parse() : { }
{
	{ init(); }
	( header() <LINEBREAK> )*
	graph()
	( footer() <LINEBREAK> )*
	<END> (<ANY>)*
	<EOF>
	{ return stg; }}

void header() : { List<String> list; }
{
  	(<LINEBREAK>)?
	(
	  	<INPUT_HEADER> list = stringList() { addSignals (list, Type.INPUT); }
		|<OUTPUT_HEADER> list = stringList() { addSignals (list, Type.OUTPUT); }
		|<INTERNAL_HEADER> list = stringList() { addSignals (list, Type.INTERNAL); }
		|<DUMMY_HEADER> list = stringList() { addDummies (list); }
		|<UNSUPPORTED_HEADER> <REST>
	)
}

List<String> stringList() : { Token t; List<String> list = new LinkedList<String>(); }
{
	( t = <NAME> { list.add (t.image); } ) * 
	{return list;}
}

void footer() : { }
{
	<MARKING> marking()
	|<CAPACITY> capacity()
	|<UNSUPPORTED_HEADER> <REST>
}

void capacity() : { }
{
	(capacityEntry()) *
}

void capacityEntry() : { STGPlace p; int value; }
{
	 ( 
	 	(p = implicitPlaceReference() | p =  explicitPlaceReference())
	        value = assignment()
	 )
	 {
	 	p.setCapacity(value);
	 }
}

void marking() : { }
{
	"{" (markingEntry()) * "}"
}

int assignment() : { Token t; }
{
	"=" t = <INTEGER> { return Integer.parseInt(t.image); }
}

void markingEntry() : { STGPlace p; int value = 1; }
{
	 ( 
	 	(p = implicitPlaceReference() | p =  explicitPlaceReference())
	        ( value = assignment() ) ?
	 )
	 {
	 	p.setTokens(value);
	 }
}

STGPlace implicitPlaceReference() : 
{
  	Node t1, t2;
	Token t;
	Integer tokens = null;
}
{
	("<" t1 = anyTransition() "," t2 = anyTransition() ">")
	{
		return implicitPlaces.get(Pair.of(t1,t2));
	}
}

STGPlace explicitPlaceReference() : 
{
	Token t;
	String name;
	Integer tokens = null;
}
{
	( t = <NAME> { name = t.image; } )
	{
		return (STGPlace) stg.getNodeByReference (name);
	}
}

void graph() : { }
{
	<GRAPH> <LINEBREAK>
	( graphLine() <LINEBREAK> )*
}

Triple<String, Direction, Integer> signalTransition() : 
{
	Token t;
	String name;
	Direction direction;
	Integer instance = null;
}
{
	t = <NAME> { name = t.image; }
	t = <DIRECTION> { direction = Direction.fromString(t.image);}
	(
		( "/" t = <INTEGER> ) { instance = Integer.parseInt(t.image); } 
	)? 
	
	{ return Triple.of (name, direction, instance); }	
	
}

Pair<String, Integer> dummyTransition() :
{
	Token t;
	String name;
	Integer instance = null;
}
{
	t = <NAME> { name = t.image; }
	( "/" t = <INTEGER>  { instance = Integer.parseInt(t.image); } )?
	
	{ return Pair.of (name, instance); }	
	
}

Node anyTransition() :
{
	Triple<String, Direction, Integer> r;
	Pair<String, Integer> r2;
	Node t;
}
{
	(
	  LOOKAHEAD(signalTransition())
	  r = signalTransition() { t = getOrCreate(r); }
	| r2 = dummyTransition() { t = getOrCreate(r2); }
)
	{
		return t;
	}
}

void graphLine() : 
{
	Token t;
	Node from, to;
}
{
	(
	  LOOKAHEAD(<NAME>(<DIRECTION>|"/"))
	  from = anyTransition()
	| t = <NAME> { from = getOrCreate(t.image); }
	)

	(
		(
	  LOOKAHEAD(<NAME>(<DIRECTION>|"/"))
		to = anyTransition()
		| t = <NAME> { to = getOrCreate(t.image); }
		) { createArc(from, to); } 
	)* 	
}
