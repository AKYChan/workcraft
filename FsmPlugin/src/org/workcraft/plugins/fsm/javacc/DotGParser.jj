/**
 * JavaCC file
 */options{    JDK_VERSION = "1.7";    LOOKAHEAD= 1;    STATIC = false;}PARSER_BEGIN(DotGParser)package org.workcraft.plugins.fsm.javacc;import java.util.HashSet;import java.util.HashMap;import java.util.List;
import java.util.LinkedList;
import org.workcraft.dom.Node;
import org.workcraft.plugins.fsm.Event.Direction;
import org.workcraft.plugins.fsm.Symbol.Type;
import org.workcraft.plugins.fsm.*;import org.workcraft.util.Pair;import org.workcraft.exceptions.FormatException;public class DotGParser{    private HashMap < String, Type > signals;    private HashSet < String > dummies;    private Fsm fsm;    private void init() {        signals = new HashMap < String, Type > ();        dummies = new HashSet < String > ();        fsm = new Fsm();    }
    private State getOrCreateState(String name) {
        Node node = fsm.getNodeByReference(name);
        if (node == null) {
            node = fsm.createState(name);
        }
        if (!(node instanceof State)) {
            throw new FormatException("Node " + name + " is not a state.");
        }
        return (State) node;
    }

    private Symbol getOrCreateSymbol(String name) {
        Symbol symbol = null;
        if ( !name.equals(Fsm.EPSILON_SERIALISATION) ) {            Node node = fsm.getNodeByReference(name);
        	if (node == null) {
            	symbol = fsm.createSymbol(name);
        	} else if (node instanceof Symbol) {
        	    symbol = (Symbol)node;
        	} else {            	throw new FormatException("Node \"" + name + "\" already exists and it is not a symbol.");
        	}
        }
        return symbol;
    }
    private void createEvent(State fromState, State toState, Symbol symbol) {        Event event = fsm.connect(fromState, toState, symbol);    }    private void addSignals(List < String > list, Type type) {        for (String name : list) {            if (signals.containsKey(name)) {                Type prevType = signals.get(name);                if (!prevType.equals(type)) {                    throw new FormatException("The " + type + " signal \"" + name
                        + "\" was already listed as an " + prevType + " signal.");                }            } else if (dummies.contains(name)) {                throw new FormatException("The " + type + " \"" + name
                    + "\" was already listed as a dummy.");            } else {                signals.put(name, type);            }        }    }    private void addDummies(List < String > list) {        for (String name : list) {            if (signals.containsKey(name)) {                Type type = signals.get(name);                throw new FormatException("The dummy \"" + name
                    + "\" was already listed as an " + type + " signal.");            } else {                dummies.add(name);            }        }    }}PARSER_END(DotGParser)<* >SKIP :{    " "
|   "\t"
}< IGNORE_LINE >TOKEN :{    < REST : (~["\r", "\n"])* > : DEFAULT}< IGNORE_ALL >TOKEN :{    < ANY : ~[ ] >}TOKEN :{
    < COMMENT: "#" (~["\r", "\n"])* >|   < LINEBREAK : ((< COMMENT >)? [ "\r", "\n" ])+ >|   < INPUT_HEADER : ".inputs" >|   < OUTPUT_HEADER : ".outputs" >|   < INTERNAL_HEADER : ".internal" >|   < DUMMY_HEADER : ".dummy" >|   < STATE_GRAPH : ".state graph" >|   < MARKING : ".marking" >|   < END : ".end" > : IGNORE_ALL|   < UNSUPPORTED_HEADER : "." < NAME >> : IGNORE_LINE|   < NAME : [ "A"-"Z", "a"-"z", "_" ] ([ "_", "A"-"Z", "a"-"z", "0"-"9" ])* >|   < DIRECTION : [ "+", "-", "~" ] >|   < INTEGER : ([ "0"-"9" ])+ >|   "{"|   "}"|   "<"|   ">"|   ","|   "/"|   "="}Fsm parse() :{}{    {        init();    }    (        header() < LINEBREAK >    )*    graph()    (        footer() < LINEBREAK >    )*    < END > (< ANY >)* < EOF >    {        return fsm;    }}void header() :{    List < String > list;}{    (< LINEBREAK >)?    (        < INPUT_HEADER > list = stringList()        {            addSignals(list, Type.INPUT);        }    |   < OUTPUT_HEADER > list = stringList()        {            addSignals(list, Type.OUTPUT);        }    |   < INTERNAL_HEADER > list = stringList()        {            addSignals(list, Type.INTERNAL);        }    |   < DUMMY_HEADER > list = stringList()        {            addDummies(list);        }    |   < UNSUPPORTED_HEADER > < REST >    )}List < String > stringList() :{    Token t;    List < String > list = new LinkedList < String > ();}{    (        t = < NAME >        {            list.add(t.image);        }    )*    {        return list;    }}void footer() :{}{    < MARKING > marking()|   < UNSUPPORTED_HEADER > < REST >}void marking() :{    Token t;
    State state;}{    "{" t = < NAME > "}"    {
        state = getOrCreateState(t.image);    }    {        state.setInitial(true);    }}void graph() :{}{    < STATE_GRAPH > < LINEBREAK >    (        graphLine() < LINEBREAK >    )*}Pair < String, Direction > signalEvent() :{    Token t;    String name;    Direction direction;}{    t = < NAME >    {        name = t.image;    }    t = < DIRECTION >    {        direction = Direction.fromString(t.image);    }    {        return Pair.of(name, direction);    }}String dummyEvent() :{    Token t;    String name;}{    t = < NAME >    {        name = t.image;    }    {        return name;    }}void graphLine() :{    Token t;    State fromState;
    Symbol symbol;    State toState;}{    (        t = < NAME >        {            fromState = getOrCreateState(t.image);        }    )    (        (
            t = < NAME >            {                symbol = getOrCreateSymbol(t.image);            }        )        (            t = < NAME >            {                toState = getOrCreateState(t.image);            }        )        {            createEvent(fromState, toState, symbol);            fromState = toState;        }    )+}
