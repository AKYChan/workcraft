/*
*
* Copyright 2008,2009 Newcastle University
*
* This file is part of Workcraft.
*
* Workcraft is free software: you can redistribute it and/or modify
* it under the terms of the GNU General Public License as published by
* the Free Software Foundation, either version 3 of the License, or
* (at your option) any later version.
*
* Workcraft is distributed in the hope that it will be useful,
* but WITHOUT ANY WARRANTY; without even the implied warranty of
* MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
* GNU General Public License for more details.
*
* You should have received a copy of the GNU General Public License
* along with Workcraft.  If not, see <http://www.gnu.org/licenses/>.
*
*/

package org.workcraft.plugins.dfs.serialisation;

import java.io.OutputStream;
import java.io.PrintWriter;
import java.util.HashMap;
import java.util.UUID;

import org.workcraft.dom.Model;
import org.workcraft.dom.Node;
import org.workcraft.dom.hierarchy.NamespaceHelper;
import org.workcraft.exceptions.ArgumentException;
import org.workcraft.plugins.dfs.ControlRegister;
import org.workcraft.plugins.dfs.CounterflowLogic;
import org.workcraft.plugins.dfs.CounterflowRegister;
import org.workcraft.plugins.dfs.Dfs;
import org.workcraft.plugins.dfs.Logic;
import org.workcraft.plugins.dfs.MathDelayNode;
import org.workcraft.plugins.dfs.PopRegister;
import org.workcraft.plugins.dfs.PushRegister;
import org.workcraft.plugins.dfs.Register;
import org.workcraft.serialisation.Format;
import org.workcraft.serialisation.ModelSerialiser;
import org.workcraft.serialisation.ReferenceProducer;
import org.workcraft.util.LogUtils;

public class VerilogSerialiser implements ModelSerialiser {

    private static final String KEYWORD_OUTPUT = "output";
    private static final String KEYWORD_INPUT = "input";
    private static final String KEYWORD_MODULE = "module";
    private static final String KEYWORD_ENDMODULE = "endmodule";

    class ReferenceResolver implements ReferenceProducer {
        HashMap<Object, String> refMap = new HashMap<>();

        @Override
        public String getReference(Object obj) {
            return refMap.get(obj);
        }
    }

    @Override
    public ReferenceProducer serialise(Model model, OutputStream out, ReferenceProducer refs) {
        if (model instanceof Dfs) {
            PrintWriter writer = new PrintWriter(out);
            writer.println("// Verilog netlist file generated by Workcraft -- http://workcraft.org/\n");
            writeModule(writer, (Dfs) model);
            writer.close();
        } else {
            throw new ArgumentException("Model class not supported: " + model.getClass().getName());
        }
        return new ReferenceResolver();
    }

    @Override
    public boolean isApplicableTo(Model model) {
        return model instanceof Dfs;
    }

    @Override
    public String getDescription() {
        return "Workcraft Verilog serialiser";
    }

    @Override
    public String getExtension() {
        return ".v";
    }

    @Override
    public UUID getFormatUUID() {
        return Format.VERILOG;
    }

    private void writeModule(PrintWriter out, Dfs dfs) {
        writeHeader(out, dfs);
        writeInstances(out, dfs);
        out.println(KEYWORD_ENDMODULE);
    }

    private void writeHeader(PrintWriter out, Dfs dfs) {
        String topName = dfs.getTitle();
        if ((topName == null) || topName.isEmpty()) {
            topName = "UNTITLED";
            LogUtils.logWarningLine("The top module does not have a name. Exporting as `" + topName + "` module.");
        }
        out.print(KEYWORD_MODULE + " " + topName + " (");
        out.println(");");
        out.println("    //" + KEYWORD_INPUT + "...;");
        out.println("    //" + KEYWORD_OUTPUT + "...;");
        out.println();
    }

    private void writeInstances(PrintWriter out, Dfs dfs) {
        for (Logic l: dfs.getLogics()) {
            writeInstance(out, dfs, l);
        }
        for (Register r: dfs.getRegisters()) {
            writeInstance(out, dfs, r);
        }
        for (CounterflowLogic l: dfs.getCounterflowLogics()) {
            writeInstance(out, dfs, l);
        }
        for (CounterflowRegister r: dfs.getCounterflowRegisters()) {
            writeInstance(out, dfs, r);
        }
        for (ControlRegister r: dfs.getControlRegisters()) {
            writeInstance(out, dfs, r);
        }
        for (PushRegister r: dfs.getPushRegisters()) {
            writeInstance(out, dfs, r);
        }
        for (PopRegister r: dfs.getPopRegisters()) {
            writeInstance(out, dfs, r);
        }
    }

    private void writeInstance(PrintWriter out, Dfs dfs, MathDelayNode node) {
        String instanceRef = dfs.getNodeReference(node);
        String instanceFlatName = NamespaceHelper.hierarchicalToFlatName(instanceRef);
        String moduleName = node.getClass().getName();
        out.print("    " + moduleName + " " + instanceFlatName + " (");
        boolean first = true;
        int inIndex = 0;
        for (Node predNode: dfs.getPreset(node)) {
            if (first) {
                first = false;
            } else {
                out.print(", ");
            }
            String wireName = dfs.getNodeReference(predNode) + "_" + instanceFlatName;
            String contactName = "in" + inIndex++;
            out.print("." + contactName + "(" + wireName + ")");
        }
        int outIndex = 0;
        for (Node succNode: dfs.getPostset(node)) {
            if (first) {
                first = false;
            } else {
                out.print(", ");
            }
            String wireName = instanceFlatName + "_" + dfs.getNodeReference(succNode);
            String contactName = "out" + outIndex++;
            out.print("." + contactName + "(" + wireName + ")");
        }
        out.print(");\n");
    }

}
