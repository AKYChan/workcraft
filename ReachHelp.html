<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN">
<HTML>
<HEAD>
	<META HTTP-EQUIV="CONTENT-TYPE" CONTENT="text/html; charset=iso-8859-1">
	<TITLE></TITLE>
	<META NAME="GENERATOR" CONTENT="LibreOffice 3.5  (Linux)">
	<META NAME="CREATED" CONTENT="20131218;16560000">
	<META NAME="CHANGED" CONTENT="20131218;17040000">
	<STYLE TYPE="text/css">
	<!--
		@page { margin: 0.79in }
		P { margin-bottom: 0.04in }
		P.western { font-size: 11pt }
		P.cjk { font-size: 10pt; font-weight: normal }
		H1 { margin-top: 0.09in; margin-bottom: 0.08in }
		H1.western { font-family: "Times New Roman", serif; font-size: 16pt }
		H1.cjk { font-family: "WenQuanYi Zen Hei"; font-weight: normal }
		H1.ctl { font-family: "Lohit Hindi" }
	-->
	</STYLE>
</HEAD>
<BODY LANG="en-GB" DIR="LTR">
<H1 CLASS="western" ALIGN=LEFT>Constants</H1>
<P CLASS="western" ALIGN=LEFT><B>true</B>, <B>false</B></P>
<P CLASS="western" ALIGN=LEFT>integers</P>
<P CLASS="western" ALIGN=LEFT>strings (e.g. &quot;Hello&quot;)</P>
<P CLASS="western" ALIGN=LEFT>events, conditions, places,
transitions, signals - cannot be directly specified, but returned by
some operators, like C, E, P, T, S, etc.</P>
<H1 CLASS="western" ALIGN=LEFT>Variables</H1>
<P CLASS="western" ALIGN=LEFT>Built of English letters, digits and
'_', not starting with a digit, case sensitive.</P>
<H1 CLASS="western" ALIGN=LEFT>Unary operators</H1>
<P CLASS="western" ALIGN=LEFT><B>fail</B> string // creates a special
failure expression to report errors; has a complicated semantics</P>
<P CLASS="western" ALIGN=LEFT><B>$</B> event or <B>$</B> condition or
<B>$</B> place or <B>$</B> signal // Interpreted on the configuration
C to be reached: returns true iff the event is in C, or the condition
is in Cut(C), or the place is in Mark(C), or the signal is 1 in
Code(C)</P>
<P CLASS="western" ALIGN=LEFT><B>@</B> event or <B>@</B> transition
or <B>@</B> signal // Interpreted on the configuration C to be
reached: returns true iff C enables event/transition/signal</P>
<P CLASS="western" ALIGN=LEFT>signal <B>'</B> // Interpreted on the
configuration C to be reached: returns true iff the next state of
signal is high in the final state of C; equivalent to ($ signal ^ @
signal)</P>
<P CLASS="western" ALIGN=LEFT><B>C</B> number // Finds a condition by
number</P>
<P CLASS="western" ALIGN=LEFT><B>E</B> number // Finds an event by
number</P>
<P CLASS="western" ALIGN=LEFT><B>P</B> name or <B>P</B> number //
Finds a place by name or number</P>
<P CLASS="western" ALIGN=LEFT><B>T</B> name or <B>T</B> number //
Finds a transition by name or number</P>
<P CLASS="western" ALIGN=LEFT><B>S</B> name or <B>S</B> number //
Finds a signal by name or number</P>
<P CLASS="western" ALIGN=LEFT><B>PP</B> regular_expression // Finds a
set of places whose names match the given regular expression</P>
<P CLASS="western" ALIGN=LEFT><B>TT</B> regular_expression // Finds a
set of transitions whose names match the given regular expression</P>
<P CLASS="western" ALIGN=LEFT><B>SS</B> regular_expression // Finds a
set of signals whose names match the given regular expression</P>
<P CLASS="western" ALIGN=LEFT><B>#</B> event or <B>#</B> condition or
<B>#</B> place or <B>#</B> transition or <B>#</B> signal // returns
the number of a condition, event, place, transition or signal</P>
<P CLASS="western" ALIGN=LEFT><B>name</B> place or <B>name</B>
transition or <B>name</B> signal // returns the name of a place,
transition or signal</P>
<P CLASS="western" ALIGN=LEFT><B>string</B> expression // returns a
string representation of the argument</P>
<P CLASS="western" ALIGN=LEFT><B>downclose</B> event or <B>downclose</B>
set_of_events // downcloses an event or a set thereof, returning a
set of events</P>
<P CLASS="western" ALIGN=LEFT><B>trig</B> event // Computes the set
of triggers of an event, returning a set of events</P>
<P CLASS="western" ALIGN=LEFT><B>is_init</B> event or is_init
condition or is_init place or is_init transition or is_init signal //
Checks if a condition/place is initially marked, or an
event/transition/signal is initially enabled</P>
<P CLASS="western" ALIGN=LEFT><B>is_cutoff</B> event // Checks if an
event is cut-off</P>
<P CLASS="western" ALIGN=LEFT><B>is_input</B> signal // Checks if a
signal is an input</P>
<P CLASS="western" ALIGN=LEFT><B>is_output</B> signal // Checks if a
signal is an output</P>
<P CLASS="western" ALIGN=LEFT><B>is_internal</B> signal // Checks if
a signal is internal</P>
<P CLASS="western" ALIGN=LEFT><B>is_dummy</B> signal // Checks if a
signal is dummy</P>
<P CLASS="western" ALIGN=LEFT><B>is_local</B> signal // Checks if a
signal is local</P>
<P CLASS="western" ALIGN=LEFT><B>is_plus</B> event or <B>is_plus</B>
transition // Checks if an STG event or transition has a sign '+'</P>
<P CLASS="western" ALIGN=LEFT><B>is_minus</B> event or <B>is_minus</B>
transition // Checks if an STG event or transition has a sign '-'</P>
<P CLASS="western" ALIGN=LEFT><B>~</B> bool // Boolean negation</P>
<P CLASS="western" ALIGN=LEFT><B>-</B> number // Unary minus</P>
<P CLASS="western" ALIGN=LEFT><B>pre</B> event or <B>pre</B>
condition or <B>pre</B> place or <B>pre</B> transition or <B>pre</B>
set_of_events or <B>pre</B> set_of_conditions or <B>pre</B>
set_of_places or <B>pre</B> set_of_transitions // preset of a node or
set of nodes</P>
<P CLASS="western" ALIGN=LEFT><B>post</B> event or <B>post</B>
condition or <B>post</B> place or post transition or <B>post</B>
set_of_events or <B>post</B> set_of_conditions or <B>post</B>
set_of_places or <B>post</B> set_of_transitions &nbsp;&nbsp; //
postset of a node or set of nodes</P>
<P CLASS="western" ALIGN=LEFT><B>cond</B> place or <B>cond</B>
set_of_places // Set of conditions corresponding to a place or a
place set</P>
<P CLASS="western" ALIGN=LEFT><B>evs</B> transition or <B>evs</B>
signal or <B>evs</B> set_of_transitions or <B>evs</B> set_of_signals
// Set of events corresponding to a transition, a signal, a
transition set or a signal set</P>
<P CLASS="western" ALIGN=LEFT><B>pls</B> condition or <B>pls</B>
set_of_conditions // Place corresponding to a condition, or place set
corresponding to a condition set</P>
<P CLASS="western" ALIGN=LEFT><B>tran</B> event or <B>tran</B>
set_of_events or <B>tran</B> signal or <B>tran</B> set_of_signals //
Transition corresponding to an event, or transition set corresponding
to an event set, a signal or a signal set</P>
<P CLASS="western" ALIGN=LEFT><B>sig</B> event or <B>sig</B>
transition or <B>sig</B> set_of_events or <B>sig</B> set_of_
transitions // Signal corresponding to an event or a transition, or
signal set corresponding to event set or an transition set</P>
<P CLASS="western" ALIGN=LEFT><B>card</B> set // Set cardinality</P>
<H1 CLASS="western" ALIGN=LEFT>Binary operators</H1>
<P CLASS="western" ALIGN=LEFT>&amp;, |, ^, <B>-&gt;</B>, <B>&lt;-&gt;</B>
// Boolean AND, OR, XOR, implication, and equivalence</P>
<P CLASS="western" ALIGN=LEFT><B>+</B>, <B>-</B>, <B>*</B>, <B>/</B>,
<B>%</B> // numerical operators as usual</P>
<P CLASS="western" ALIGN=LEFT><B>=</B>, <B>!=</B> // equality and
non-equality for non-Booleans, as long as the argument types agree;
for Booleans use <B>&lt;-&gt;</B> and <B>^</B> instead</P>
<P CLASS="western" ALIGN=LEFT><B>&lt;</B>, <B>&lt;=</B>, <B>&gt;</B>,
<B>&gt;=</B> // numerical comparisons and set inclusion</P>
<P CLASS="western" ALIGN=LEFT><B>+</B> // string concatenation</P>
<P CLASS="western" ALIGN=LEFT><B>+</B>, <B>*</B>, <B>\</B> // set
union, intersection, and difference</P>
<P CLASS="western" ALIGN=LEFT>element <B>in</B> set // set membership</P>
<H1 CLASS="western" ALIGN=LEFT>Ternary operators</H1>
<P CLASS="western" ALIGN=LEFT>string<B>[</B>number<B>..</B>number<B>]</B>
// returns a substring of a string</P>
<P CLASS="western" ALIGN=LEFT>condition <B>?</B> expression <B>:</B>
expression // conditional expression, like in C/C++</P>
<H1 CLASS="western" ALIGN=LEFT>Multi-operand operators</H1>
<P CLASS="western" ALIGN=LEFT><B>threshold[</B>number<B>](</B>bool<B>,</B>
bool<B>,</B> &hellip;<B>,</B> bool<B>)</B> // Multi-operand threshold
operator; if <B>[</B>number<B>]</B> is dropped, 2 is assumed</P>
<P CLASS="western" ALIGN=LEFT><B>{</B>expression<B>,</B> expression<B>,</B>
&hellip;<B>,</B> expression<B>}</B> // constructs a set out of
several expressions of the same type; an empty set cannot be
constructed in this way, as its type cannot be determined</P>
<H1 CLASS="western" ALIGN=LEFT>Iterators</H1>
<P CLASS="western" ALIGN=LEFT>Below the &ldquo;s.t.&rdquo; clause is
optional:</P>
<P CLASS="western" ALIGN=LEFT><B>forall</B> var <B>in</B> set <B>s.t.</B>
predicate <B>{</B> expression <B>}</B> // constructs an
AND-expression by filtering and transforming elements of the given
set</P>
<P CLASS="western" ALIGN=LEFT><B>exists</B> var <B>in</B> set <B>s.t.</B>
predicate <B>{</B> expression <B>}</B> // constructs an OR-expression
by filtering and transforming elements of the given set</P>
<P CLASS="western" ALIGN=LEFT><B>xorsum</B> var <B>in</B> set <B>s.t.</B>
predicate <B>{</B> expression <B>}</B> // constructs an
XOR-expression by filtering and transforming elements of the given
set</P>
<P CLASS="western" ALIGN=LEFT><B>threshold[</B>number<B>]</B> var <B>in</B>
set <B>s.t.</B> predicate <B>{</B> expression <B>}</B> // constructs
a threshold operator by filtering and transforming elements of the
given set; if <B>[</B>number<B>]</B> is dropped, 2 is assumed</P>
<P CLASS="western" ALIGN=LEFT><B>gather</B> var <B>in</B> set <B>s.t.</B>
predicate <B>{</B> expression <B>}</B> // constructs a set by
filtering and transforming elements of the given set</P>
<H1 CLASS="western" ALIGN=LEFT>Name declaration</H1>
<P CLASS="western" ALIGN=LEFT><B>let</B> var<B>=</B>value <B>{</B>
expression <B>}</B> // creates a name with a fixed value and scope</P>
<P CLASS="western" ALIGN=LEFT STYLE="margin-bottom: 0in"><BR>
</P>
</BODY>
</HTML>