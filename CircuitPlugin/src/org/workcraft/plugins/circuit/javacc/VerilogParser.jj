/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.7";
  LOOKAHEAD = 1;
  STATIC = false;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(VerilogParser)
package org.workcraft.plugins.circuit.javacc;

import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

import org.workcraft.dom.Node;
import org.workcraft.util.Pair;
import org.workcraft.util.Triple;
import org.workcraft.exceptions.InvalidConnectionException;
import org.workcraft.exceptions.FormatException;
import org.workcraft.exceptions.NotFoundException;

public class VerilogParser {
        
    public class Module {        public final String name;
        public final List<Port> ports;
        public final List<Instance> instances;
        public Module(String name, List<Port> ports, List<Instance> instances) {            this.name = name;
            this.ports = ports;
            this.instances = instances;
        }
    }

    public class Port {
        public final String name;
        public final String type;
        public Port(String name, String type) {
            this.name = name;
            this.type = type;
        }
    }

    
    
    public class Instance {
        public final String name;
        public final String moduleName;
        public final List<Connection> connections;
        public Instance(String name, String moduleName, List<Connection> connections) {
            this.name = name;
            this.moduleName = moduleName;
            this.connections = connections;
        }
    }

    public class Connection {
        public final String name;
        public final String netName;
        public Connection(String name, String netName) {
            this.name = name;
            this.netName = netName;
        }
    }
}
PARSER_END(VerilogParser)

SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
|   <"//" (~["\r", "\n"])*>
|   < "`" (~["\r", "\n"])*> 
|   "specify" : WITHIN_SPECIFY 
|   "primitive" : WITHIN_PRIMITIVE
}

<WITHIN_SPECIFY> SKIP:
{
	"endspecify" : DEFAULT
|	<~[]>
}

<WITHIN_PRIMITIVE> SKIP:
{
	"endprimitive" : DEFAULT
|	<~[]>
}

TOKEN :
{
    <MODULE : "module">
|   <ENDMODULE : "endmodule">
|   <INPUT : "input">
|   <OUTPUT : "output">
|   <INOUT : "inout">
|   <REG : "reg">
|   <WIRE : "wire">
|   <NAME : [ "A"-"Z", "a"-"z", "_" ] ([ "_", "A"-"Z", "a"-"z", "0"-"9" ])* >
|   <LOGIC0 : "1'b0">
|   <LOGIC1 : "1'b1">
|   <INTEGER : ([ "0"-"9" ])+>
|   "("
|   ")"
|   "["
|   "]"
|   ","
|   ";"
|   "."
}    
    
List<Module> parseCircuit() :
{
    List<Module> modules; 
}
{
    modules = parseModules()
    {
        return modules;
    }
}

List<Module> parseModules():
{
    Module module;
    List<Module> modules = new LinkedList<Module>();}
{
    (        module = parseModule()
        {            modules.add(module);
        }
    )*
    {        return modules;
    }
}
    
Module parseModule():
{
    Token name;
    List<Port> ports; 
    List<Instance> instances; 
}
{
    <MODULE> name = <NAME>
    ports = parsePorts()
    instances = parseInstances()
    <ENDMODULE>
    {        return new Module(name.image, ports, instances);
    }
}

List<Port> parsePorts():
{
    List<Port> ports;
}
{
    (
    	LOOKAHEAD(parseCompactPorts())        ports = parseCompactPorts()
  	|   ports = parseComplexPorts()
    )
    {
        return ports;
    }
}

List<Port> parseCompactPorts():
{
    Port port;
    List<Port> ports = new LinkedList<Port>();
}
{
	[
		"("
   		(
       		port = parseCompactPort() [","]
       		{
	           	ports.add(port);
    	   	}
   		)*
    	")"
    ]
    ";"
    {
        return ports;
    }
}

Port parseCompactPort():
{
    Token nameToken;
    Token typeToken;
}
{
    (typeToken = <INPUT> | typeToken = <OUTPUT> | typeToken = <INOUT>) nameToken = <NAME>
    {
    	String name = nameToken.image;
    	String type = typeToken.image;
    	return new Port(name, type);
    }
}

List<Port> parseComplexPorts():
{
    List<String> declarations;
    List<Port> definitions;
}
{
	declarations = parsePortsDeclaration()
	definitions = parsePortsDefinitions()
    {
    	HashMap<String, String> nameToType = new HashMap<String, String>();
    	for (Port port: definitions) {
    		nameToType.put(port.name, port.type);
    	}
    	List<Port> ports = new LinkedList<Port>();
   		for (String name: declarations) {
   			String type = nameToType.get(name);
    		ports.add(new Port(name, type));
    	}
        return ports;
    }
}

List<String> parsePortsDeclaration():
{
    List<String> names = null;
}
{
    ["(" names = parseNames() ")"] ";"
	{
		List<String> ports = new LinkedList<String>();
		if (names != null) {
			ports.addAll(names);
		}
		return ports;
	}
}

List<Port> parsePortsDefinitions():
{
    List<Port> ports;
    List<Port> allPorts = new LinkedList<Port>();
}
{
    (
    	ports = parsePortsDefinition()
    	{
    		allPorts.addAll(ports);
    	}
    )*
    {
    	return allPorts;
    }
}

List<Port> parsePortsDefinition():
{    List<String> names = new LinkedList<String>();
    Token typeToken;
}
{
    (typeToken = <INPUT> | typeToken = <OUTPUT> | typeToken = <INOUT> | typeToken = <REG> | typeToken = <WIRE>) names = parseNames() ";"
    {
    	String type = typeToken.image;
    	List<Port> ports = new LinkedList<Port>();
    	for (String name: names) {
    		Port port = new Port(name, type);
    		ports.add(port);        }
     	return ports;
    }
}

List<String> parseNames():
{
    Token nameToken;
    List<String> names = new LinkedList<String>();
}
{
    (
        nameToken = <NAME> [","]
        {
        	String name = nameToken.image;
            names.add(name);
        }
    )*
    {
    	return names;
    }
}

List<Instance> parseInstances():
{
    Instance instance;
    List<Instance> instances = new LinkedList<Instance>();
}
{
    (
       	instance = parseInstance()
        {
            instances.add(instance);
        }
    )*
    {
        return instances;
    }
}

Instance parseInstance():
{
    Token moduleNameToken;
    Token nameToken = null;
    List<String> parameters;
    List<Connection> connections;
}
{
    moduleNameToken = <NAME>  [nameToken = <NAME>]
    (
    "(" connections = parseConnections() ")"
    )+ 
    ";"
    {
    	String moduleName = moduleNameToken.image;
    	String name = (nameToken == null ? null : nameToken.image);
        return new Instance(name, moduleName, connections);
    }
}

List<Connection> parseConnections():
{
    List<Connection> connections;
}
{
    (
    	LOOKAHEAD(parseNamedConnection())
        connections = parseNamedConnections()
    |   connections = parseOrderedConnections()
    )
    {
        return connections;
    }
}

List<Connection> parseNamedConnections():
{
    Connection connection;
    List<Connection> connections = new LinkedList<Connection>();
}
{
    (
        connection = parseNamedConnection()
        {
            connections.add(connection);
        }
    )*
    {
        return connections;
    }
}

Connection parseNamedConnection():
{
    Token portName;
    Token netName;
}
{
    "." portName = <NAME> "(" netName = <NAME> ")" [","]
    {
        return new Connection(portName.image, netName.image);
    }
}

List<Connection> parseOrderedConnections():
{
    List<String> wires;
    List<Connection> connections = new LinkedList<Connection>();
}
{
	wires = parseNames()
    {
    	for (String wire: wires) {
    		Connection connection = new Connection(null, wire);
    		connections.add(connection);
    	}
        return connections;
    }
}

/*
List<String> parseWires():
{
	String wire;
    List<String> wires = new LinkedList<String>();
}
{
    (
        wire = parseWire() [","]
        {
            wires.add(wire);
        }
    )*
    {
    	return wires;
    }
}

String parseWire():
{
	Token wireToken = null;
}
{
    (
    	wireToken = <NAME> 
    |	wireToken = <LOGIC0> 
    |	wireToken = <LOGIC1>
    ) 
	{
		return (wireToken == null ? null : wireToken.image);
	}
}
*/