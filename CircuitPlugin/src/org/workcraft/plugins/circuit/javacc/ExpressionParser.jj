/**
 * JavaCC file
 */
 
options {
  JDK_VERSION = "1.7";
  LOOKAHEAD = 1;
  STATIC = false;
  DEBUG_PARSER = true;
}

PARSER_BEGIN(ExpressionParser)
package org.workcraft.plugins.circuit.javacc;

import java.util.HashSet;
import java.util.HashMap;
import java.util.List;
import java.util.LinkedList;

import org.workcraft.dom.Node;
import org.workcraft.util.Pair;
import org.workcraft.util.Triple;
import org.workcraft.exceptions.InvalidConnectionException;
import org.workcraft.exceptions.FormatException;
import org.workcraft.exceptions.NotFoundException;

public class ExpressionParser {
    
    public interface Expression {
    	public String toString();
    }

    public class ExpressionExpression implements Expression {
        public final List<Expression> expressions;
        public ExpressionExpression(List<Expression> expressions) {
            this.expressions = expressions;
        }
        public String toString() {
        	String result = "";
        	boolean first = true;
        	for (Expression expression: expressions) {
        		if (!first) {
        			result += "+";
        		}
        		result += expression.toString();
        		first = false;
        	}
        	return result;
        }
    }

    public class TermExpression implements Expression {
        public final List<Expression> expressions;
        public TermExpression(List<Expression> expressions) {
            this.expressions = expressions;
        }
        public String toString() {
        	String result = "";
        	boolean first = true;
        	for (Expression expression: expressions) {
        		if (!first) {
        			result += "*";
        		}
        		result += expression.toString();
        		first = false;
        	}
        	return result;
        }
    }
    
    public class FactorExpression implements Expression {
        public final Expression expression;
        public FactorExpression(Expression expression) {
            this.expression = expression;
        }
        public String toString() {
        	return "(" + expression.toString() + ")";
        }
    }

    public class NotExpression implements Expression {
        public final Expression expression;
        public NotExpression(Expression expression) {
            this.expression = expression;
        }
        public String toString() {
        	return expression.toString() + "'";
        }
    }

    public class LiteralExpression implements Expression {
        public final String name;
        public LiteralExpression(String name) {
            this.name = name;
        }
        public String toString() {
        	return name;
        }
    }

    public class ConstantExpression implements Expression {
        public final boolean value;
        public ConstantExpression(boolean value) {
            this.value = value;
        }
        public String toString() {
        	return (value ? "1" : "0");
        }
    }
    
}
PARSER_END(ExpressionParser)

SKIP:
{
    " "
|   "\t"
|   "\r"
|   "\n"
|   <"#" (~["\r", "\n"])*>
}

TOKEN :
{
    <CONST0 : "CONST0">
|   <CONST1 : "CONST1">
|   <NAME : [ "A"-"Z", "a"-"z", "_" ] ([ "_", "A"-"Z", "a"-"z", "0"-"9" ])* >
|   "("
|   ")"
|   "+"
|   "*"
|   "!"
}

Expression parseExpression():
{
	Expression term;
	List<Expression> terms = new LinkedList<Expression>();
}
{
	(
		term = parseTerm()
		{
			terms.add(term);
		}
		( "+"  term = parseTerm() )*
		{
			terms.add(term); 
		}
	)
	{
		return new ExpressionExpression(terms);
	}
}

Expression parseTerm():
{
	Expression factor;
	List<Expression> factors = new LinkedList<Expression>();
}
{
	(
		factor = parseFactor()
		{
			factors.add(factor);
		} 
		( ["*"] factor = parseFactor() )*
		{
			factors.add(factor);
		} 
	)
	{
		return new TermExpression(factors);
	}
}

Expression parseFactor():
{
	Expression factor;
}
{
	(
		factor = parseLiteral()
	|	factor = parseConstant()
	|	"!" factor = parseFactor()
		{
			return new NotExpression(factor);
		}
	| 	"(" factor = parseExpression() ")"
	)
	{
		return factor;
	}
}

Expression parseLiteral():
{
	Token nameToken;
}
{
	nameToken = <NAME>
	{
		String name = nameToken.image;
		return new LiteralExpression(name);
	}
}

Expression parseConstant():
{
}
{
	( 
		<CONST0>
		{
			return new ConstantExpression(false);
		}
	|	<CONST1>
		{
			return new ConstantExpression(true);
		}
	)
}
